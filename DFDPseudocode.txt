Beckman DFD translation to Psuedocode 

#==========================================================================
# 1) Call these inside a larger function to write input file ? 
#==========================================================================

# Function to generate input file for fresco. Potentially ambitious to try 
to implement, because each input file is different depending on what type 
of reaction is modeled (elastic, inelastic, breakup, transfer)
# Would need to call multiple functions to do this  

# First Function: Fill out the namelist section of the input file
namelist(hcm, jmax, rxn, elab)
	open input file template
	line = line.replace("RR")     #place hcm (radial step) in place of variable in input file template
	line = line.replace("JJ")     #place jmax (max partial waves) in place of variable input file template
	line = line.replace("QQ")     #place q variable in 
        line = line.replace("RXN")    #place description of reaction at top of file (A+B->C+D, energy, etc)
	line = line.replace("EE")     #place elab in place of variable in inputfile
return "Namelist added" 

# Second Function: Fill out the partition section of the input file
states(targ ID, proj ID, nex)
	open previously saved input file 
	read in targ ID information from IAEA or NNDC data file (A,Z, BE, gs to excited state level scheme info)
	place A, Z, BE in place of variable in input file template
	write file/save to OneDrive
return "added states to" input file 

# Third Function: Fill out the potential section of the input file 
pot(option)
	Enter arrays of global potential parameters, assign an ID within the function (1,2,3 etc)
	select option of which potential parameter (1,2,3)
	write potential section of input file based on selected array of parameters
return "added potential" to input file 

#==========================================================================
# 2) SSH into remote server, run fresco (python)
#==========================================================================

import paramiko
from scp import SCPClient
import os
import subprocess
import matplotlib.pyplot as plt
import numpy as np
import pandas as pd
import sys
import getpass

#==============================================================================
# 3) Function definitions called late script to analysis
#==============================================================================

def unnest(listlist):
    flat_list = []
    for element in listlist:
        if type(element) is list:
            for item in element:
                flat_list.append(item)
        else:
            flat_list.append(element)
    return flat_list

#==============================================================================
# 4) SSH and scp client 
#==============================================================================


# Connection details
midhost = 'nsclgw2.nscl.msu.edu'
user = 'beckman'
midpassword = getpass.getpass(prompt='Password: ')
finalhost = 'fishtank'
finaluser = 'beckman'
final_password = getpass.getpass(prompt='Password: ')
final_port = 22

# Define local location to save files to, check if it exists
localdir = "/Users/catebeckman/OneDrive - Michigan State University/15C_brkup/15Cremoterun"
if os.path.exists(localdir)==True:
    print("Local directory found")
else: 
    print("Local directory not found")


try:
    # Connect to the intermediate server
    intermediate_ssh = paramiko.SSHClient()
    intermediate_ssh.set_missing_host_key_policy(paramiko.AutoAddPolicy())
    intermediate_ssh.connect(midhost, username=user, password=midpassword)
    
    # Open a transport session to the intermediate server
    transport = intermediate_ssh.get_transport()
    channel = transport.open_channel('direct-tcpip', (finalhost, final_port), ('local host', 0))
    
    # Use this channel to connect to fishtank
    final_ssh = paramiko.SSHClient()
    final_ssh.set_missing_host_key_policy(paramiko.AutoAddPolicy())
    final_ssh.connect(finalhost, username=user, password=final_password, sock=channel)

    commands = '''
                cd /user/beckman/15C_brkup/runfile
                chmod +x 15Cbrkup.run
                ./15Cbrkup.run
                '''
                
    print('executing command lines')
    stdin, stdout, stderr = final_ssh.exec_command(commands)
    print(stdout.read().decode())
    print("Successfully connected to the final server.")
    
    # Download relevant files to local machine 
    sftp = final_ssh.open_sftp()
    # Define dictionary to transfer files. Adds file name to local directory to 
    # make full local filepath
    transferdict = {
        '/user/beckman/15C_brkup/runfile/15Cangular': os.path.join(localdir, '15Cangular'),
        '/user/beckman/15C_brkup/runfile/15Cenergy': os.path.join(localdir, '15Cenergy')
    }
    
    # Save remote file to local, print error messages
    for remote_path, local_path in transferdict.items():
        print(f'Transferring {remote_path} to {local_path}')
        try:
            sftp.get(remote_path, local_path)
        except FileNotFoundError as e:
            print(f"FileNotFound: {e}")
        except IOError as e:
            print(f"IOError: {e}")
            
                
    sftp.close()
    print("Files transferred successfully.")
    
    
except paramiko.AuthenticationException:
    print("Authentication failed. Please check your credentials.")
except paramiko.SSHException as e:
    print(f"SSH error: {e}")
except Exception as e:
    print(f"An error occurred: {e}")
 
     
finally:
    # Ensure all connections are closed
    if 'final_ssh' in locals():
        final_ssh.close()
    if 'intermediate_ssh' in locals():
        intermediate_ssh.close()
    if 'channel' in locals():
        channel.close()

#==============================================================================
# 5) Pull data from files
#==============================================================================

os.chdir(localdir)
outfile1 = '15Cangular' #replace back with fstring 


# preallocate
unnestcproj = []
thettot = []
cstot = []

#Open fort.16 file
with open(outfile1) as f1:
    #skip the first 13 lines which are meant for X plotting
    y = f1.readlines()[0:100]
    #split up each row and get rid of the spaces 
    contenthan = [x.strip().split() for x in y]
print('File Read')

#Un-nest the list
unnestcproj = unnest(contenthan)


#Index over even vs odd to separate angle and cross section
for x in range(0, len(unnestcproj)):
    if x % 2:
        cstot.append(float(unnestcproj[x])/1000)
    else : 
        thettot.append(float(unnestcproj[x]))
print('cross sections saved')

#==============================================================================
# 6) Plot Breakup Cross Section
#==============================================================================

plt.plot(thettot, cstot, 'b', label='Breakup Cross Section')
plt.xlim(0,100)
plt.title('Elastic Scattering')
plt.legend()
plt.title('Elastic Scattering', y=1.03)
plt.ylabel('Absolute Cross Section (mb/str)')
plt.xlabel('$^{CM}\Theta$')
plt.legend(loc=0)
plt.show() 
filename = input("Input plot name to save: ")
plt.savefig(os.path.join(localdir, filename))

#================================================================================
# 7) Convergence Plots
#================================================================================

# Function to replace X with whatever you want in file for jbord, and Y
def converge(file, X, Y, Z):
    with open(file, 'r') as f:
        content = f.readlines()

        new_content = []
        newfiles = []
        for line in content:
            line = line.replace("XX", str(X))
            line = line.replace("YY", str(Y))
            line = line.replace("ZZ", str(Z))
            new_content.append(line)
        new_file = f"{file.split('.')[0]}_{i+1}.{file.split('.')[1]}"
        newfiles.append(new_file)
        with open(new_file, 'w') as f:
            f.writelines(new_content)
        
    return newfiles

os.chdir("/Users/catebeckman/OneDrive - Michigan State University/15C_brkup/potentials/convg")
inputarr = []
# User inputs, filename, variable name
filelist = list(map(str, input("Enter the .run file: ").split(',')))
inputarr = list(map(str, input("Input jbord X Y Z as list (),(): ").split(',')))


#print(allnewfiles)

# Preallocate space, if you change theta increments, you need to change below 
unnesthan = []
unnestsum = []


cs = np.zeros((len(inputarr)*len(filelist) // 2, 100))
inel = np.zeros((len(filelist)*len(inputarr) // 2, 100))
cstotal = np.zeros((len(inputarr)*len(filelist) // 2, 102))
print("size of cs array:", np.shape(cs))
energy = np.zeros((len(inputarr)*len(filelist) // 2, 20))
energycs = np.zeros((len(inputarr)*len(filelist) // 2, 20))

#Loop using f string, which allows to replace a string with something callable
for i, file in enumerate(filelist):
    count = 0
    
    #Preallocate in loop so they clear on each iteration
    
    
    #Get to directory after entering file list for CDCC calcs
    os.chdir("/Users/catebeckman/OneDrive - Michigan State University/15C_brkup/potentials/convg")
    filename = file.replace(".run", "")
    print("Directory: ", filename)
    
    os.chdir("/Users/catebeckman/OneDrive - Michigan State University/15C_brkup/potentials/convg")
    fileindex = i+1
    print("Source File: ", file)
    
    allnewfiles = []
    # Use converge function to replace X and Y in jbord with your inputs 
    xhold = []
    xinp = []
    yinp = []
    zinp = []
    for i in range(0, len(inputarr), 3):
        xinp.append(inputarr[i])
        yinp.append(inputarr[i+1]) 
        zinp.append(inputarr[i+2])
    
      
    for i in range(0, len(xinp)):
        newfiles = converge(file, xinp[i], yinp[i], zinp[i])
        allnewfiles.append(newfiles)
    
    allnewfiles = unnest(allnewfiles)
    print('Files created:', allnewfiles)
    
    
    for newfile in allnewfiles:
        cshold =[]
        inelhold = []
        theta = []
        csholdtot = []
        thetatot = []
        outfile = []
        csE = []
        energyholder = []
        
        newfilename = newfile.replace(".run", "")
        
        print('File being run in terminal: ', newfilename)
        command = f'''
            cd "/Users/catebeckman/OneDrive - Michigan State University/15C_brkup/potentials/convg" || exit
            chmod +x {newfile}
            ./{newfile}
            /Users/catebeckman/bin/cdc < {filename}.cdcc > {newfilename}.in  || exit
            /Users/catebeckman/bin/fresco < {newfilename}.in > {newfilename}.out
            cp fort.16 {newfilename}_16 || exit
            cp fort.13 {newfilename}_13 || exit
            /Users/catebeckman/bin/fres/util/sumbins < fort.16 > {newfilename}angular || exit
            /Users/catebeckman/bin/fres/util/sumxen < fort.13 > {newfilename}energy || exit
                  '''
        bashresults = subprocess.run(command, capture_output=True, shell=True)
        print("stdout:", bashresults.stdout.decode())
        print("stderr:", bashresults.stderr.decode())
        print(f"File {newfilename} run success")
        print(f"{newfilename}_16")
    
    
    
        #Get to correct directory in order to open the fort16 file
        os.chdir("/Users/catebeckman/OneDrive - Michigan State University/15C_brkup/potentials/convg")
        outfile = f'{newfilename}_16'

        #Open fort.16 file
        with open(outfile) as f:
            y = f.readlines()
            #skip the first 13 lines which are meant for X plotting
            #split up each row and get rid of the spaces 
            contenthan = [x.strip().split() for x in y[13:113]]
            inelcontent = [x.strip().split() for x in y[120:220]]
        

        #Un-nest the list
        unnesthan = unnest(contenthan)
        inellist= unnest(inelcontent)
    
        #Index over even vs odd to separate angle and cross section 
        for x in range(0, len(unnesthan)):
            if x % 2:
                #print(float((unnesthan[x])))
                cshold.append(float(unnesthan[x]))
                inelhold.append(float(inellist[x]))
            else: 
                theta.append(float(unnesthan[x]))        
                # Fill each row of cross section arrays, determined by # inputs, with cross sections
        #cs[i, :len(cshold)]=cshold 
        #inel[i, :len(inelhold)]=inelhold
    
        outfile = f'{newfilename}angular'
        with open(outfile) as f:
            y = f.readlines()
            content = [x.strip().split() for x in y[0:102]]
        
        unnestsum = unnest(content)
    
        for x in range(0, len(unnestsum)):
            if x % 2:
                csholdtot.append(float(unnestsum[x]))
            else:
                thetatot.append(float(unnestsum[x]))
    
        #cstotal[i, :len(csholdtot)] = csholdtot
    
        outfile2 = f"{newfilename}energy"
        with open(outfile2) as f:
            y = f.readlines()
            content = [x.strip().split() for x in y[4:24]]
        
        unnestenergy = unnest(content)
    
        for x in range(0, len(unnestenergy)):
            if x % 2:
                csE.append(float(unnestenergy[x]))
            else:
                energyholder.append(float(unnestenergy[x]))

        
        # save cross section information from each file into one array
        cs[count, :len(cshold)]=cshold 
        inel[count, :len(inelhold)]=inelhold
    
	# save energy info from each file into one array
        energycs[count, :len(csE)] = csE
        energy[count, :len(energyholder)] = energyholder
    
        # save total cross section from each file into one array
        cstotal[count, :len(csholdtot)] = csholdtot

        count += 1
    
print("loop ended")  

# Plot the elastic cross section for each the varying partial waves
for i, file in enumerate(allnewfiles): 
    #Add to Plot 
    filename = file.replace(f"convg_{i+1}.run", "")
    print(filename)
    os.chdir("/Users/catebeckman/OneDrive - Michigan State University/15C_brkup/potentials/convg")
    plt.plot(theta, cs[i], label = f"{filename}")
print("loop done")
plt.yscale('log')
plt.xlim(0,100)
plt.ylim(0.01,10000)
plt.yticks([0.01, 0.1, 1, 10, 100, 1000, 10000])
plt.legend()
plt.title('Elastic Scattering', y=1.03)
plt.ylabel('Absolute Cross Section (mb/str)')
plt.xlabel('$^{CM}\Theta$')
plt.legend(loc=0)
plt.show()

# Plot the total breakup cross section for each varying partial wave file 
for i, file in enumerate(allnewfiles): 
    #Add to Plot 
    filename = file.replace(f"convg_{i+1}.run", "")
    os.chdir("/Users/catebeckman/OneDrive - Michigan State University/15C_brkup/potentials/convg")
    plt.plot(thetatot, cstotal[i], label = f"{xinp[i]},{yinp[i]}")
plt.yscale('log')
plt.xlim(0,100)
plt.ylim(0.01,10000)
plt.yticks([0.01, 0.1, 1, 10, 100, 1000, 10000])
plt.legend()
plt.title('Breakup Cross Section', y=1.03)
plt.ylabel('Absolute Cross Section (mb/str)')
plt.xlabel('$^{CM}\Theta$')
plt.legend(loc=0)
plt.show()

# Plot rel E for each varying partial wave file
for i, file in enumerate(allnewfiles): 
    #Add to Plot 
    filename = file.replace(f"convg_{i+1}.run", "")
    os.chdir("/Users/catebeckman/OneDrive - Michigan State University/15C_brkup/potentials/convg")
    plt.plot(energy[i], energycs[i], label = f"{xinp[i]},{yinp[i]}")
plt.legend()
plt.title('Relative Energy n-14C', y=1.03)
plt.ylabel('Absolute Cross Section (mb/str)')
plt.xlabel('Energy (MeV)')
plt.legend(loc=0)
plt.show()

#==============================================================================
# 8) Send to advisor, no code for, manual
#==============================================================================
